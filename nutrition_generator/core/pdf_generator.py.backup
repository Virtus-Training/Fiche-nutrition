"""
PDF generator REFONTE COMPLETE - Sans bugs critiques.
Correction de tous les problèmes d'affichage de code et objets Python.
"""

from __future__ import annotations

import os
import json
import math
import io
from datetime import datetime
from typing import Any, Dict, List, Optional

import numpy as np

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import cm
from reportlab.lib.colors import Color, HexColor, white
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
    Image,
    PageBreak,
)
from reportlab.graphics.shapes import Drawing, Rect, Line, Circle
from reportlab.lib.utils import ImageReader
from reportlab.platypus import HRFlowable

from core.data_models import (
    ClientData,
    NutritionResults,
    FORMULES_METABOLISME,
    NIVEAUX_ACTIVITE,
)
from core.calculations import NutritionCalculator


class PremiumPDFGenerator:
    """Générateur PDF SANS BUGS - Version corrigée."""

    def __init__(self, config_path: Optional[str] = None) -> None:
        self.config = self._load_config(config_path)
        self.colors = self._define_color_palette()
        self.styles = self._build_style_guide()
        self._add_clean_styles()  # Ajouter les styles clean
        self.calculator = NutritionCalculator()
        self.logo_path = self._resolve_logo_path()
        self.include_logo = True  # ACTIVER le logo
        self.section_spacing = 8  # COMPACTER l'espacement

        self.icons = {
            "profile": "\U0001F464",
            "metabolism": "\u26A1",
            "maintenance": "\U0001F3AF",
            "objective": "\U0001F3C3",
            "macros_chart": "\U0001F4CA",
            "macros_table": "\U0001F4C8",
            "advice": "\U0001F4A1",
            "hydration": "\U0001F6B0",
            "timing": "\u23F0",
            "focus": "\U0001F3AF",
            "warning": "\u26A0",
            "weight": "\U0001F4C8",
        }

        plt.rcParams.update(
            {
                "font.family": "sans-serif",
                "font.sans-serif": ["Helvetica", "Arial", "DejaVu Sans"],
                "font.size": 10,
                "axes.titleweight": "bold",
                "axes.edgecolor": "#D8DDE5",
                "axes.labelcolor": "#2C3E50",
                "axes.grid": True,
                "grid.color": "#E5E8EB",
                "grid.linestyle": "--",
                "grid.alpha": 0.45,
                "axes.spines.top": False,
                "axes.spines.right": False,
                "axes.spines.left": False,
                "axes.spines.bottom": False,
                "legend.frameon": False,
                "figure.autolayout": False,
            }
        )

    # ------------------------------------------------------------------
    # Configuration & palette
    # ------------------------------------------------------------------
    def _project_root(self) -> str:
        return os.path.dirname(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        )

    def _load_config(self, config_path: Optional[str]) -> Dict[str, Any]:
        if config_path and os.path.exists(config_path):
            return self._read_config(config_path)

        module_dir = os.path.dirname(os.path.abspath(__file__))
        default_path = os.path.join(os.path.dirname(module_dir), "config", "settings.json")
        if os.path.exists(default_path):
            return self._read_config(default_path)

        return {
            "coach_info": {
                "name": "Virtus Training",
                "title": "Nutrition & Performance Coach",
                "instagram": "virtus.training_",
                "phone": "07 69 39 43 83",
                "email": "virtustraining.fit@gmail.com",
                "website": "www.virtus-training.fr",
            }
        }

    def _read_config(self, path: str) -> Dict[str, Any]:
        with open(path, "r", encoding="utf-8") as handler:
            config = json.load(handler)

        config.setdefault(
            "coach_info",
            {
                "name": "Virtus Training",
                "title": "Nutrition & Performance Coach",
                "instagram": "virtus.training_",
                "phone": "07 69 39 43 83",
                "email": "virtustraining.fit@gmail.com",
                "website": "www.virtus-training.fr",
            },
        )
        return config

    def _resolve_logo_path(self) -> Optional[str]:
        """Résoudre le chemin du logo - PRIORITÉ à Logo.png racine"""
        project_root = self._project_root()

        # PRIORITÉ ABSOLUE au Logo.png de la racine
        priority_paths = [
            os.path.join(project_root, "Logo.png"),
            os.path.join(project_root, "logo.png"),
        ]

        for path_candidate in priority_paths:
            if os.path.exists(path_candidate):
                return path_candidate

        # Fallback sur config si Logo.png introuvable
        branding = self.config.get("branding")
        if isinstance(branding, dict):
            candidate = branding.get("logo_path")
            if candidate:
                if not os.path.isabs(candidate):
                    candidate = os.path.join(project_root, candidate)
                if os.path.exists(candidate):
                    return candidate

        return None

    def _define_color_palette(self) -> Dict[str, Color]:
        """Palette de couleurs PREMIUM définitive"""
        return {
            "primary": HexColor("#2E86AB"),     # Bleu principal
            "secondary": HexColor("#6C757D"),   # Gris neutre
            "success": HexColor("#27AE60"),     # Vert (surplus/réussite)
            "danger": HexColor("#E74C3C"),      # Rouge (déficit/attention)
            "warning": HexColor("#F39C12"),     # Orange (maintenance)
            "light": HexColor("#F8F9FA"),       # Gris très clair
            "white": HexColor("#FFFFFF"),       # Blanc pur
            "dark": HexColor("#2C3E50"),        # Bleu foncé pour textes

            # Compatibilité avec l'ancien code
            "primary_dark": HexColor("#1976D2"),
            "accent_loss": HexColor("#E74C3C"),
            "accent_gain": HexColor("#27AE60"),
            "accent_maintain": HexColor("#F39C12"),
            "neutral_dark": HexColor("#2C3E50"),
            "neutral_medium": HexColor("#6C757D"),
            "neutral_light": HexColor("#DCE3E9"),
            "card_bg": HexColor("#F8F9FA"),
            "page_bg": HexColor("#FAFAFA"),
            "card_border": HexColor("#E1E6EB"),
            "chart_protein": HexColor("#2E86AB"),
            "chart_fat": HexColor("#E74C3C"),
            "chart_carb": HexColor("#27AE60"),
        }

    def _tint_color(self, color: Color, factor: float) -> Color:
        factor = max(0.0, min(1.0, factor))
        return Color(
            color.red + (1.0 - color.red) * factor,
            color.green + (1.0 - color.green) * factor,
            color.blue + (1.0 - color.blue) * factor,
        )

    def _hex(self, color: Color) -> str:
        try:
            value = color.hexval()
        except AttributeError:
            value = "#%02x%02x%02x" % (
                int(color.red * 255),
                int(color.green * 255),
                int(color.blue * 255),
            )
        else:
            if value.startswith("0x") or value.startswith("0X"):
                value = "#" + value[2:]
            if not value.startswith("#"):
                value = "#" + value.lstrip("#")
        return value.upper()

    def _build_style_guide(self) -> Dict[str, ParagraphStyle]:
        stylesheet = getSampleStyleSheet()
        styles: Dict[str, ParagraphStyle] = {}

        styles["body"] = ParagraphStyle(
            "PremiumBody",
            parent=stylesheet["BodyText"],
            fontName="Helvetica",
            fontSize=10,
            leading=14,
            textColor=self.colors["neutral_dark"],
        )

        # HIÉRARCHIE TYPOGRAPHIQUE STRICTE selon le prompt
        styles["section_title"] = ParagraphStyle(
            "SectionTitle",
            fontName="Helvetica-Bold",
            fontSize=12,        # Uniforme pour tous les titres
            leading=16,
            spaceAfter=6,       # Réduit
            spaceBefore=8,      # Réduit
            textColor=HexColor('#2E86AB'),
            alignment=TA_LEFT,
        )

        styles["subsection_title"] = ParagraphStyle(
            "SubSection",
            fontName="Helvetica-Bold",
            fontSize=10,
            leading=12,
            spaceBefore=4,
            spaceAfter=4,
            textColor=HexColor('#2C3E50'),
        )

        styles["section_caption"] = ParagraphStyle(
            "SectionCaption",
            fontName="Helvetica",
            fontSize=9,
            leading=12,
            textColor=self.colors["neutral_medium"],
        )

        styles["header_title"] = ParagraphStyle(
            "HeaderTitle",
            fontName="Helvetica-Bold",
            fontSize=20,
            leading=22,
            textColor=self.colors["white"],
            alignment=TA_CENTER,
        )

        styles["header_subtitle"] = ParagraphStyle(
            "HeaderSubtitle",
            fontName="Helvetica",
            fontSize=12,
            leading=14,
            textColor=self._tint_color(self.colors["white"], -0.2),
            alignment=TA_CENTER,
        )

        styles["header_contact"] = ParagraphStyle(
            "HeaderContact",
            fontName="Helvetica",
            fontSize=9,
            leading=11,
            textColor=self.colors["white"],
            alignment=TA_RIGHT,
        )

        styles["header_composite"] = ParagraphStyle(
            "HeaderComposite",
            fontName="Helvetica",
            fontSize=10,
            leading=14,
            textColor=self.colors["white"],
            alignment=TA_CENTER,
        )

        styles["header_contact_block"] = ParagraphStyle(
            "HeaderContactBlock",
            fontName="Helvetica",
            fontSize=9,
            leading=11,
            textColor=self.colors["white"],
            alignment=TA_RIGHT,
        )

        styles["kpi_value"] = ParagraphStyle(
            "KPIValue",
            fontName="Helvetica-Bold",
            fontSize=18,
            leading=22,
            textColor=self.colors["primary"],
            alignment=TA_CENTER,
        )

        styles["kpi_unit"] = ParagraphStyle(
            "KPIUnit",
            fontName="Helvetica",
            fontSize=9,
            leading=11,
            textColor=self.colors["neutral_medium"],
            alignment=TA_CENTER,
        )

        styles["card_hint"] = ParagraphStyle(
            "CardHint",
            fontName="Helvetica",
            fontSize=9,
            leading=11,
            textColor=self.colors["neutral_medium"],
            alignment=TA_CENTER,
        )

        styles["macro_header"] = ParagraphStyle(
            "MacroHeader",
            fontName="Helvetica-Bold",
            fontSize=11,
            leading=14,
            textColor=self.colors["primary"],
            alignment=TA_LEFT,
        )

        styles["macro_cell"] = ParagraphStyle(
            "MacroCell",
            fontName="Helvetica",
            fontSize=10,
            leading=13,
            textColor=self.colors["neutral_dark"],
        )

        styles["macro_total"] = ParagraphStyle(
            "MacroTotal",
            fontName="Helvetica-Bold",
            fontSize=10,
            leading=13,
            textColor=self.colors["primary_dark"],
        )

        styles["advice_heading"] = ParagraphStyle(
            "AdviceHeading",
            fontName="Helvetica-Bold",
            fontSize=11,
            leading=14,
            textColor=self.colors["primary"],
        )

        styles["advice_bullet"] = ParagraphStyle(
            "AdviceBullet",
            fontName="Helvetica",
            fontSize=10,
            leading=13,
            leftIndent=10,
            textColor=self.colors["neutral_dark"],
        )

        styles["footer_primary"] = ParagraphStyle(
            "FooterPrimary",
            fontName="Helvetica",
            fontSize=9,
            leading=12,
            alignment=TA_CENTER,
            textColor=self.colors["neutral_dark"],
        )

        styles["footer_secondary"] = ParagraphStyle(
            "FooterSecondary",
            fontName="Helvetica",
            fontSize=8,
            leading=11,
            alignment=TA_CENTER,
            textColor=self.colors["neutral_medium"],
        )

        return styles

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    def _format_int(self, value: float) -> str:
        return format(value, ",.0f").replace(",", " ")

    def _format_decimal(self, value: float, decimals: int = 1) -> str:
        formatted = format(value, f",.{decimals}f")
        formatted = formatted.replace(",", " ")
        return formatted.replace(".", ",")

    def _format_signed(self, value: float) -> str:
        formatted = format(value, "+,.0f")
        formatted = formatted.replace(",", " ")
        return formatted

    def _activity_description(self, factor: float) -> str:
        if factor in NIVEAUX_ACTIVITE:
            return NIVEAUX_ACTIVITE[factor]

        closest = min(NIVEAUX_ACTIVITE.keys(), key=lambda x: abs(x - factor))
        if abs(closest - factor) <= 0.05:
            return NIVEAUX_ACTIVITE[closest]
        return "Niveau d'activite personnalise"

    def _profile_cell(self, label: str, value: str, value_color: Optional[Color] = None) -> Paragraph:
        label_color = self._hex(self.colors["neutral_medium"])
        value_color_hex = self._hex(value_color or self.colors["neutral_dark"])
        text = (
            f"<para align='left'><font size=8 color='{label_color}'>{label.upper()}</font><br/>"
            f"<font size=12 color='{value_color_hex}'><b>{value}</b></font></para>"
        )
        return Paragraph(text, self.styles["body"])

    def _build_logo_compact(self) -> Optional[Image]:
        """Logo compact pour header optimisé"""
        if not self.logo_path:
            return None
        try:
            from PIL import Image as PILImage
            with PILImage.open(self.logo_path) as pil_logo:
                pil_logo = pil_logo.convert("RGBA")
                width_px, height_px = pil_logo.size
                if width_px == 0 or height_px == 0:
                    return None

                # TAILLE COMPACTE pour header
                target_size = 2.2 * cm  # Plus petit
                aspect = width_px / height_px
                if aspect >= 1.0:
                    target_width = target_size
                    target_height = target_size / aspect
                else:
                    target_height = target_size
                    target_width = target_size * aspect

                buffer = io.BytesIO()
                pil_logo.save(buffer, format="PNG")
                buffer.seek(0)

            logo = Image(buffer, width=target_width, height=target_height)
            logo.hAlign = "CENTER"
            return logo
        except Exception:
            return None

    def _build_logo(self) -> Optional[Image]:
        if not self.logo_path:
            return None
        try:
            from PIL import Image as PILImage
            with PILImage.open(self.logo_path) as pil_logo:
                pil_logo = pil_logo.convert("RGBA")
                width_px, height_px = pil_logo.size
                if width_px == 0 or height_px == 0:
                    return None
                max_side = 2.8 * cm
                aspect = width_px / height_px
                if aspect >= 1.0:
                    target_width = max_side
                    target_height = max_side / aspect
                else:
                    target_height = max_side
                    target_width = max_side * aspect
                buffer = BytesIO()
                pil_logo.save(buffer, format="PNG")
                buffer.seek(0)
            logo = Image(buffer, width=target_width, height=target_height)
            logo.hAlign = "LEFT"
            return logo
        except Exception:
            return None

    def _decorative_separator(self, width: float, primary: Color, accent: Color) -> Drawing:
        drawing = Drawing(width, 0.45 * cm)
        drawing.add(Rect(0, 0.18 * cm, width, 0.09 * cm, fillColor=primary, strokeColor=None))
        drawing.add(Rect(0, 0.08 * cm, width, 0.05 * cm, fillColor=self._tint_color(primary, 0.55), strokeColor=None))
        drawing.add(Circle(0.25 * cm, 0.22 * cm, 0.12 * cm, fillColor=accent, strokeColor=None))
        drawing.add(Circle(width - 0.25 * cm, 0.22 * cm, 0.12 * cm, fillColor=accent, strokeColor=None))
        drawing.add(Line(0.55 * cm, 0.35 * cm, width - 0.55 * cm, 0.35 * cm, strokeColor=self._tint_color(accent, 0.35), strokeWidth=1))
        return drawing
    # ------------------------------------------------------------------
    # Header
    # ------------------------------------------------------------------
    def create_perfect_header(self) -> Table:
        """Header avec coordonnées parfaitement visibles selon le prompt sublime"""
        coach_info = self.config.get("coach_info", {})

        # Style contact optimisé
        contact_style = ParagraphStyle(
            name='ContactStyle',
            fontSize=9,
            fontName='Helvetica',
            textColor=self.colors['white'],
            alignment=2,  # Aligné à droite
            leading=11,
            spaceAfter=1
        )

        # Coordonnées complètes sur 3 lignes courtes
        contact_text = """
        Instagram : @virtus.training_<br/>
        Tél : 07 69 39 43 83<br/>
        Email : virtustraining.fit@gmail.com
        """

        # Logo compact avec placeholder si nécessaire
        logo_cell = self.create_logo_placeholder()

        # Titre parfaitement centré
        title_cell = self.create_centered_title()

        # Structure header avec largeurs ajustées
        header_data = [
            [
                logo_cell,  # 70px
                title_cell, # 370px
                Paragraph(contact_text, contact_style)  # 180px
            ]
        ]

        header_table = Table(header_data, colWidths=[70, 370, 180])
        header_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, -1), HexColor('#2E86AB')),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centré
            ('ALIGN', (1, 0), (1, 0), 'CENTER'),  # Titre centré
            ('ALIGN', (2, 0), (2, 0), 'RIGHT'),   # Contact à droite
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('TOPPADDING', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
            ('LEFTPADDING', (2, 0), (2, 0), 8),
            ('RIGHTPADDING', (2, 0), (2, 0), 8),
        ]))

        return header_table

    def create_logo_placeholder(self):
        """Créer un placeholder logo ou utiliser le logo existant"""
        logo_image = self._build_logo_compact()
        if logo_image is None:
            # Placeholder professionnel
            logo_style = ParagraphStyle(
                name='LogoPlaceholder',
                fontSize=10,
                fontName='Helvetica-Bold',
                textColor=self.colors['white'],
                alignment=1
            )
            return Paragraph("<b>VIRTUS<br/>TRAINING</b>", logo_style)
        return logo_image

    def create_centered_title(self) -> Paragraph:
        """Titre parfaitement centré selon le prompt"""
        title_style = ParagraphStyle(
            name='HeaderTitle',
            fontSize=15,
            fontName='Helvetica-Bold',
            textColor=self.colors['white'],
            alignment=1,  # Centré
            leading=17
        )

        return Paragraph(
            "<b>FICHE NUTRITIONNELLE<br/>PERSONNALISÉE<br/>COACHING PROFESSIONNEL</b>",
            title_style
        )

    # Alias pour compatibilité
    def create_clean_header(self) -> Table:
        return self.create_perfect_header()

    def create_title_cell(self) -> Paragraph:
        """Cellule titre propre - version héritée"""
        return self.create_centered_title()

    def _build_header(self) -> List[Any]:
        """Version mise à jour utilisant le header clean"""
        elements: List[Any] = []

        # Header propre
        elements.append(self.create_clean_header())
        elements.append(Spacer(1, 20))

        return elements
    def _build_profile_section(
        self,
        client: ClientData,
        results: NutritionResults,
        params: Dict[str, Any],
    ) -> List[Any]:
        elements: List[Any] = []
        # TERMINOLOGIE CHALEUREUSE
        title = Paragraph(
            f"{self.icons['profile']} PROFIL PERSONNEL",
            self.styles["section_title"],
        )
        elements.append(title)

        deficit = params.get("deficit_surplus_kcal", 0)
        if deficit < -100:
            objectif_text = "Perte de poids"
            objectif_color = self.colors["accent_loss"]
        elif deficit > 100:
            objectif_text = "Prise de masse"
            objectif_color = self.colors["accent_gain"]
        else:
            objectif_text = "Recomposition / Maintenance"
            objectif_color = self.colors["accent_maintain"]

        objectif_detail = f"{objectif_text} ({self._format_signed(deficit)} kcal/j)"
        activity_factor = params.get("facteur_activite", 1.55)
        activity_text = self._activity_description(activity_factor)

        profile_data = [
            [
                self._profile_cell("Nom", client.nom.upper()),
                self._profile_cell("Prenom", client.prenom.title()),
                self._profile_cell("Age", f"{client.age} ans"),
            ],
            [
                self._profile_cell("Taille", f"{client.taille_cm} cm"),
                self._profile_cell("Poids", f"{self._format_decimal(client.poids_kg, 1)} kg"),
                self._profile_cell(
                    "Sexe",
                    "Homme" if client.sexe == "male" else "Femme",
                ),
            ],
            [
                self._profile_cell("Activite", activity_text),
                "",
                "",
            ],
            [
                self._profile_cell("Objectif", objectif_detail, objectif_color),
                "",
                "",
            ],
        ]

        profile_table = self._create_safe_table(profile_data, [5.7 * cm, 5.7 * cm, 5.7 * cm])
        profile_table.setStyle(
            TableStyle(
                [
                    ("SPAN", (0, 2), (-1, 2)),
                    ("SPAN", (0, 3), (-1, 3)),
                    ("BACKGROUND", (0, 0), (-1, -1), self.colors["card_bg"]),
                    ("BOX", (0, 0), (-1, -1), 0.6, self.colors["card_border"]),
                    ("INNERGRID", (0, 0), (-1, -1), 0.3, self.colors["card_border"]),
                    ("LEFTPADDING", (0, 0), (-1, -1), 10),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 10),
                    ("TOPPADDING", (0, 0), (-1, -1), 8),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 6),
                    ("BACKGROUND", (0, 3), (-1, 3), self._tint_color(objectif_color, 0.82)),
                ]
            )
        )

        elements.append(profile_table)
        return elements

    # ------------------------------------------------------------------
    # Besoins caloriques
    # ------------------------------------------------------------------
    def create_cards_with_colored_borders(self, results: NutritionResults, params: Dict[str, Any]) -> Table:
        """Cards énergétiques avec bordures colorées distinctives selon le prompt sublime"""
        formula_key = params.get("formule_metabolisme", "mifflin_st_jeor")
        activity_factor = params.get("facteur_activite", 1.55)
        deficit = params.get("deficit_surplus_kcal", 0)

        # Déterminer la couleur de bordure selon l'objectif
        if deficit < -100:
            objectif_border_color = '#E74C3C'  # Rouge pour déficit
        elif deficit > 100:
            objectif_border_color = '#27AE60'  # Vert pour surplus
        else:
            objectif_border_color = '#F39C12'  # Orange pour maintenance

        cards_data = [
            {
                'title': 'MÉTABOLISME DE BASE',
                'value': f"{results.bmr:.0f}",
                'unit': 'kcal / jour',
                'hint': 'Mifflin-St Jeor',  # SIMPLIFIÉ
                'border_color': '#6C757D',  # Gris
                'accent_color': '#6C757D'
            },
            {
                'title': 'MAINTENANCE',
                'value': f"{results.calories_maintenance:.0f}",
                'unit': 'kcal / jour',
                'hint': f'BMR x {activity_factor:.2f} activité',
                'border_color': '#2E86AB',  # Bleu
                'accent_color': '#2E86AB'
            },
            {
                'title': 'OBJECTIF',
                'value': f"{results.calories_objectif:.0f}",
                'unit': 'kcal / jour',
                'hint': f'Variation de {deficit:+.0f} kcal',
                'border_color': objectif_border_color,
                'accent_color': objectif_border_color
            }
        ]

        cards = []
        for card in cards_data:
            # Contenu de la card
            card_content = [
                [Paragraph(f"<b>■ {card['title']}</b>", self.create_card_title_style())],
                [Paragraph(f"<b>{card['value']}</b>", self.create_card_value_style(card['accent_color']))],
                [Paragraph(card['unit'], self.create_card_unit_style())],
                [Paragraph(card['hint'], self.create_card_hint_style())]
            ]

            # Card avec bordure colorée épaisse
            card_table = Table(card_content, colWidths=[160], rowHeights=[25, 40, 18, 30])
            card_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, -1), HexColor('#FAFAFA')),
                ('BORDER', (0, 0), (-1, -1), 3, HexColor(card['border_color'])),  # Bordure épaisse
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('TOPPADDING', (0, 0), (-1, -1), 4),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
                # Bordure supérieure accentuée
                ('LINEABOVE', (0, 0), (-1, 0), 6, HexColor(card['border_color'])),
            ]))

            cards.append(card_table)

        # Assemblage avec espacement
        main_table = Table([cards], colWidths=[170, 170, 170])
        main_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ]))

        return main_table

    def create_card_title_style(self) -> ParagraphStyle:
        """Style pour les titres de cards"""
        return ParagraphStyle(
            name='CardTitle',
            fontSize=10,
            fontName='Helvetica-Bold',
            textColor=HexColor('#2C3E50'),
            alignment=1
        )

    def create_card_value_style(self, color: str) -> ParagraphStyle:
        """Style pour les valeurs de cards avec couleur"""
        return ParagraphStyle(
            name=f'CardValue_{color}',
            fontSize=18,
            fontName='Helvetica-Bold',
            textColor=HexColor(color),
            alignment=1
        )

    def create_card_unit_style(self) -> ParagraphStyle:
        """Style pour les unités de cards"""
        return ParagraphStyle(
            name='CardUnit',
            fontSize=9,
            fontName='Helvetica',
            textColor=HexColor('#6C757D'),
            alignment=1
        )

    def create_card_hint_style(self) -> ParagraphStyle:
        """Style pour les hints de cards"""
        return ParagraphStyle(
            name='CardHint',
            fontSize=8,
            fontName='Helvetica',
            textColor=HexColor('#6C757D'),
            alignment=1
        )

    # Alias pour compatibilité
    def create_energy_cards_no_collision(self, results: NutritionResults, params: Dict[str, Any]) -> Table:
        return self.create_cards_with_colored_borders(results, params)

    def create_clean_profile_table(self, client: ClientData, results: NutritionResults, params: Dict[str, Any]) -> Table:
        """Table profil propre selon le prompt"""
        deficit = params.get("deficit_surplus_kcal", 0)
        if deficit < -100:
            objectif_text = "Perte de poids"
            objectif_color = self.colors["accent_loss"]
        elif deficit > 100:
            objectif_text = "Prise de masse"
            objectif_color = self.colors["accent_gain"]
        else:
            objectif_text = "Recomposition / Maintenance"
            objectif_color = self.colors["accent_maintain"]

        objectif_detail = f"{objectif_text} ({self._format_signed(deficit)} kcal/j)"
        activity_factor = params.get("facteur_activite", 1.55)
        activity_text = self._activity_description(activity_factor)

        profile_data = [
            [
                self._profile_cell("Nom", client.nom.upper()),
                self._profile_cell("Prenom", client.prenom.title()),
                self._profile_cell("Age", f"{client.age} ans"),
            ],
            [
                self._profile_cell("Taille", f"{client.taille_cm} cm"),
                self._profile_cell("Poids", f"{self._format_decimal(client.poids_kg, 1)} kg"),
                self._profile_cell(
                    "Sexe",
                    "Homme" if client.sexe == "male" else "Femme",
                ),
            ],
            [
                self._profile_cell("Activite", activity_text),
                "",
                "",
            ],
            [
                self._profile_cell("Objectif", objectif_detail, objectif_color),
                "",
                "",
            ],
        ]

        profile_table = self._create_safe_table(profile_data, [5.7 * cm, 5.7 * cm, 5.7 * cm])
        profile_table.setStyle(
            TableStyle(
                [
                    ("SPAN", (0, 2), (-1, 2)),
                    ("SPAN", (0, 3), (-1, 3)),
                    ("BACKGROUND", (0, 0), (-1, -1), self.colors["card_bg"]),
                    ("BOX", (0, 0), (-1, -1), 0.6, self.colors["card_border"]),
                    ("INNERGRID", (0, 0), (-1, -1), 0.3, self.colors["card_border"]),
                    ("LEFTPADDING", (0, 0), (-1, -1), 10),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 10),
                    ("TOPPADDING", (0, 0), (-1, -1), 8),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 6),
                    ("BACKGROUND", (0, 3), (-1, 3), self._tint_color(objectif_color, 0.82)),
                ]
            )
        )

        return profile_table

    # Alias pour compatibilité
    def _build_energy_cards_uniform(self, results: NutritionResults, params: Dict[str, Any]) -> Table:
        return self.create_energy_cards_no_collision(results, params)

    def _build_caloric_needs_section(
        self,
        results: NutritionResults,
        params: Dict[str, Any],
    ) -> List[Any]:
        elements: List[Any] = []
        title = Paragraph(
            f"{self.icons['metabolism']} BESOINS ÉNERGÉTIQUES",
            self.styles["section_title"],
        )
        elements.append(title)
        elements.append(Paragraph("Vue rapide sur vos calories clefs.", self.styles["section_caption"]))
        elements.append(Spacer(1, 6))

        # Utiliser les cartes UNIFORMES
        energy_cards = self._build_energy_cards_uniform(results, params)
        elements.append(energy_cards)

        return elements

    # ------------------------------------------------------------------
    # Macros
    # ------------------------------------------------------------------
    def _create_flat_pie_chart(self, results: NutritionResults) -> Image:
        """Pie chart moderne et plat, sans effet 3D selon le prompt"""
        values = [
            results.proteines_kcal,
            results.lipides_kcal,
            results.glucides_kcal,
        ]
        labels = ['Protéines', 'Lipides', 'Glucides']

        # Couleurs modernes et contrastées selon le prompt
        colors_flat = ['#2E86AB', '#E74C3C', '#27AE60']  # Bleu, Rouge, Vert

        # GRAPHIQUE COMPACT 300 DPI
        fig, ax = plt.subplots(figsize=(5, 5), dpi=300)

        # PIE CHART PLAT ET MODERNE
        wedges, texts, autotexts = ax.pie(
            values,
            labels=labels,
            colors=colors_flat,
            autopct='%1.1f%%',
            startangle=90,
            explode=(0.02, 0.02, 0.02),  # Légère séparation sans 3D
            shadow=False,  # PAS D'OMBRE 3D
            textprops={'fontsize': 11, 'fontweight': 'bold'},
            wedgeprops={'linewidth': 1, 'edgecolor': 'white'}  # Bordure blanche
        )

        # Style des pourcentages
        for autotext in autotexts:
            autotext.set_color('white')
            autotext.set_fontweight('bold')
            autotext.set_fontsize(10)

        # Style des labels
        for text in texts:
            text.set_fontsize(10)
            text.set_fontweight('bold')
            text.set_color('#2C3E50')

        # Titre moderne
        ax.set_title('Répartition calorique',
                    fontsize=12, fontweight='bold',
                    pad=15, color='#2C3E50')

        # Assurer un cercle parfait
        ax.axis('equal')

        plt.tight_layout()

        # Sauvegarder en HAUTE RÉSOLUTION
        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight',
                   facecolor='white', edgecolor='none')
        img_buffer.seek(0)
        plt.close(fig)

        # Créer l'image ReportLab COMPACTE
        img = Image(img_buffer, width=6.0 * cm, height=6.0 * cm)
        img.hAlign = "CENTER"

        return img

    def _create_premium_pie_chart(self, results: NutritionResults) -> Image:
        """Wrapper pour compatibilité - utilise la nouvelle version plate"""
        return self._create_flat_pie_chart(results)

    def _create_premium_macro_table(self, results: NutritionResults) -> Table:
        """Tableau macros avec lisibilité optimale selon le prompt"""

        # Calculs pour les pourcentages
        total_kcal = results.proteines_kcal + results.lipides_kcal + results.glucides_kcal
        protein_pct = (results.proteines_kcal / total_kcal * 100) if total_kcal > 0 else 0
        fat_pct = (results.lipides_kcal / total_kcal * 100) if total_kcal > 0 else 0
        carb_pct = (results.glucides_kcal / total_kcal * 100) if total_kcal > 0 else 0
        total_g = results.proteines_g + results.lipides_g + results.glucides_g

        # Données avec formatage amélioré - 4 colonnes avec %
        macro_data = [
            ['MACRONUTRIMENT', 'GRAMMES', 'CALORIES', '% TOTAL'],
            ['Protéines', f"{results.proteines_g:.1f} g", f"{results.proteines_kcal:.0f} kcal", f"{protein_pct:.1f}%"],
            ['Lipides', f"{results.lipides_g:.1f} g", f"{results.lipides_kcal:.0f} kcal", f"{fat_pct:.1f}%"],
            ['Glucides', f"{results.glucides_g:.1f} g", f"{results.glucides_kcal:.0f} kcal", f"{carb_pct:.1f}%"],
            ['TOTAL', f"{total_g:.1f} g", f"{total_kcal:.0f} kcal", "100.0%"]
        ]

        # Largeurs de colonnes optimisées selon le prompt
        col_widths = [100, 70, 70, 60]  # Plus équilibré

        macro_table = Table(macro_data, colWidths=col_widths)
        macro_table.setStyle(TableStyle([
            # Header avec style premium
            ('BACKGROUND', (0, 0), (-1, 0), HexColor('#1976D2')),
            ('TEXTCOLOR', (0, 0), (-1, 0), self.colors['white']),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),

            # Lignes alternées pour lisibilité
            ('BACKGROUND', (0, 1), (-1, 1), HexColor('#F5F5F5')),
            ('BACKGROUND', (0, 3), (-1, 3), HexColor('#F5F5F5')),

            # Ligne TOTAL mise en valeur
            ('BACKGROUND', (0, -1), (-1, -1), HexColor('#E1F5FE')),
            ('FONTNAME', (0, -1), (-1, -1), 'Helvetica-Bold'),
            ('LINEABOVE', (0, -1), (-1, -1), 2, HexColor('#1976D2')),

            # Alignements et espacements
            ('ALIGN', (0, 0), (0, -1), 'LEFT'),   # Noms à gauche
            ('ALIGN', (1, 0), (-1, -1), 'CENTER'), # Chiffres centrés
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),

            # Padding pour respiration
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('LEFTPADDING', (0, 0), (-1, -1), 10),
            ('RIGHTPADDING', (0, 0), (-1, -1), 10),

            # Bordures propres
            ('GRID', (0, 0), (-1, -1), 0.5, HexColor('#BDBDBD')),
            ('BOX', (0, 0), (-1, -1), 1.5, HexColor('#1976D2')),
        ]))

        return macro_table

    def create_macro_section_side_by_side(self, results: NutritionResults) -> Table:
        """Section macros avec tableau et graphique côte à côte sans collision selon le prompt"""

        # Tableau macros optimisé
        macro_table = self.create_optimized_macro_table(results)

        # Pie chart avec taille contrôlée
        pie_chart_img = self.create_controlled_pie_chart(results)

        # Assemblage côte à côte avec espacement
        combined = Table(
            [[macro_table, pie_chart_img]],
            colWidths=[320, 200],  # Largeurs contrôlées
            rowHeights=[200]       # Hauteur fixe
        )

        combined.setStyle(TableStyle([
            ('ALIGN', (0, 0), (0, 0), 'LEFT'),   # Tableau à gauche
            ('ALIGN', (1, 0), (1, 0), 'CENTER'), # Graphique centré
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('LEFTPADDING', (0, 0), (-1, -1), 0),
            ('RIGHTPADDING', (0, 0), (-1, -1), 20),
        ]))

        return combined

    def create_optimized_macro_table(self, results: NutritionResults) -> Table:
        """Tableau macros lisible et bien formaté selon le prompt"""

        # Calculs pour les pourcentages
        total_kcal = results.proteines_kcal + results.lipides_kcal + results.glucides_kcal
        protein_pct = (results.proteines_kcal / total_kcal * 100) if total_kcal > 0 else 0
        fat_pct = (results.lipides_kcal / total_kcal * 100) if total_kcal > 0 else 0
        carb_pct = (results.glucides_kcal / total_kcal * 100) if total_kcal > 0 else 0
        total_g = results.proteines_g + results.lipides_g + results.glucides_g

        macro_data = [
            ['MACRONUTRIMENT', 'GRAMMES', 'CALORIES', '%'],
            [f'Protéines', f'{results.proteines_g:.1f} g', f'{results.proteines_kcal:.0f} kcal', f'{protein_pct:.1f}%'],
            [f'Lipides', f'{results.lipides_g:.1f} g', f'{results.lipides_kcal:.0f} kcal', f'{fat_pct:.1f}%'],
            [f'Glucides', f'{results.glucides_g:.1f} g', f'{results.glucides_kcal:.0f} kcal', f'{carb_pct:.1f}%'],
            ['TOTAL', f'{total_g:.1f} g', f'{total_kcal:.0f} kcal', '100%']
        ]

        table = Table(macro_data, colWidths=[85, 65, 75, 45])
        table.setStyle(TableStyle([
            # Header
            ('BACKGROUND', (0, 0), (-1, 0), HexColor('#1976D2')),
            ('TEXTCOLOR', (0, 0), (-1, 0), self.colors['white']),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 9),

            # Lignes alternées
            ('BACKGROUND', (0, 1), (-1, 1), HexColor('#F5F5F5')),
            ('BACKGROUND', (0, 3), (-1, 3), HexColor('#F5F5F5')),

            # Ligne TOTAL
            ('BACKGROUND', (0, -1), (-1, -1), HexColor('#E1F5FE')),
            ('FONTNAME', (0, -1), (-1, -1), 'Helvetica-Bold'),
            ('LINEABOVE', (0, -1), (-1, -1), 1, HexColor('#1976D2')),

            # Alignements
            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
            ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),

            # Espacement
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('FONTSIZE', (0, 1), (-1, -1), 8),

            # Bordures
            ('GRID', (0, 0), (-1, -1), 0.5, HexColor('#BDBDBD')),
        ]))

        return table

    def create_controlled_pie_chart(self, results: NutritionResults) -> Image:
        """Pie chart avec taille contrôlée pour éviter collision selon le prompt"""
        values = [
            results.proteines_kcal,
            results.lipides_kcal,
            results.glucides_kcal,
        ]
        labels = ['Protéines', 'Lipides', 'Glucides']
        colors_flat = ['#2E86AB', '#E74C3C', '#27AE60']

        # GRAPHIQUE COMPACT contrôlé
        fig, ax = plt.subplots(figsize=(4, 4), dpi=200)  # Plus petit

        wedges, texts, autotexts = ax.pie(
            values,
            labels=labels,
            colors=colors_flat,
            autopct='%1.1f%%',
            startangle=90,
            explode=(0.02, 0.02, 0.02),
            shadow=False,
            textprops={'fontsize': 9, 'fontweight': 'bold'},
            wedgeprops={'linewidth': 1, 'edgecolor': 'white'}
        )

        for autotext in autotexts:
            autotext.set_color('white')
            autotext.set_fontweight('bold')
            autotext.set_fontsize(8)

        for text in texts:
            text.set_fontsize(8)
            text.set_fontweight('bold')
            text.set_color('#2C3E50')

        ax.set_title('Répartition calorique',
                    fontsize=10, fontweight='bold',
                    pad=10, color='#2C3E50')

        ax.axis('equal')
        plt.tight_layout()

        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='png', dpi=200, bbox_inches='tight',
                   facecolor='white', edgecolor='none')
        img_buffer.seek(0)
        plt.close(fig)

        # Image ReportLab CONTRÔLÉE
        img = Image(img_buffer, width=5.0 * cm, height=5.0 * cm)  # Taille réduite
        img.hAlign = "CENTER"

        return img

    def create_weight_chart_clean(self, client: ClientData, params: Dict[str, Any]) -> Image:
        """Courbe de poids propre selon le prompt"""
        return self._create_weight_chart_with_grid(client, params)

    def create_conseils_with_colored_borders(self, client: ClientData, results: NutritionResults, params: Dict[str, Any]) -> List[Any]:
        """Conseils avec bordures colorées comme dans l'ancienne version selon le prompt sublime"""

        deficit = params.get("deficit_surplus_kcal", 0)
        hydration_l = results.hydratation_ml / 1000.0
        protein_per_kg = results.proteines_g / client.poids_kg if client.poids_kg else 0
        weekly_delta = (deficit * 7) / 7700.0

        # Déterminer le type d'objectif et ajuster le contenu
        if deficit < -100:
            objectif_content = f'→ Déficit contrôlé : {deficit:+.0f} kcal/j (≈ {weekly_delta:.2f} kg/sem)<br/>→ Objectif protéines : {results.proteines_g:.1f} g/j ({protein_per_kg:.1f} g/kg)<br/>→ Composez 2/3 de l\'assiette avec légumes et fibres'
        elif deficit > 100:
            objectif_content = f'→ Surplus contrôlé : {deficit:+.0f} kcal/j (≈ {weekly_delta:.2f} kg/sem)<br/>→ Protéines constantes : {results.proteines_g:.1f} g/j ({protein_per_kg:.1f} g/kg)<br/>→ Priorisez glucides complexes et lipides de qualité'
        else:
            objectif_content = f'→ Maintenance : {deficit:+.0f} kcal/j<br/>→ Protéines : {results.proteines_g:.1f} g/j ({protein_per_kg:.1f} g/kg)<br/>→ Équilibrez macro et micronutriments'

        conseils_sections = [
            {
                'title': 'HYDRATATION',
                'content': f'→ {hydration_l:.1f} L d\'eau par jour ({int(results.hydratation_ml)} ml)<br/>→ Ajoutez 250 ml avant/après entrainement',
                'border_color': '#2E86AB',  # Bleu
                'bg_color': '#E3F2FD'       # Bleu clair
            },
            {
                'title': 'TIMING DES REPAS',
                'content': '→ Gardez 60% de vos glucides autour de vos séances<br/>→ Petit-déjeuner riche en protéines pour limiter les fringales',
                'border_color': '#F39C12',  # Orange
                'bg_color': '#FFF3E0'       # Orange clair
            },
            {
                'title': 'SPÉCIFIQUE À VOTRE OBJECTIF',
                'content': objectif_content,
                'border_color': '#27AE60',  # Vert
                'bg_color': '#E8F5E8'       # Vert clair
            },
            {
                'title': 'POINTS D\'ATTENTION',
                'content': '→ Priorisez des aliments frais, évitez les ultra-transformés<br/>→ Surveillez la qualité du sommeil (7h minimum)<br/>→ Consultez votre médecin avant toute modification majeure',
                'border_color': '#E74C3C',  # Rouge
                'bg_color': '#FFEBEE'       # Rouge clair
            }
        ]

        # Styles pour les conseils
        conseil_title_style = ParagraphStyle(
            name='ConseilTitle',
            fontSize=11,
            fontName='Helvetica-Bold',
            textColor=HexColor('#2C3E50'),
            spaceBefore=0,
            spaceAfter=5
        )

        conseil_content_style = ParagraphStyle(
            name='ConseilContent',
            fontSize=10,
            fontName='Helvetica',
            textColor=HexColor('#2C3E50'),
            spaceBefore=0,
            spaceAfter=0,
            leading=12
        )

        conseils_story = []

        for conseil in conseils_sections:
            # Titre avec point coloré
            titre_avec_point = f'<font color="{conseil["border_color"]}"><b>■</b></font> <b>{conseil["title"]}</b>'

            conseil_data = [
                [Paragraph(titre_avec_point, conseil_title_style)],
                [Paragraph(conseil['content'], conseil_content_style)]
            ]

            conseil_box = Table(conseil_data, colWidths=[500])
            conseil_box.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, -1), HexColor(conseil['bg_color'])),
                ('BORDER', (0, 0), (-1, -1), 2, HexColor(conseil['border_color'])),
                ('LINEABOVE', (0, 0), (-1, 0), 4, HexColor(conseil['border_color'])),  # Bordure top épaisse
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('LEFTPADDING', (0, 0), (-1, -1), 12),
                ('RIGHTPADDING', (0, 0), (-1, -1), 12),
            ]))

            conseils_story.append(conseil_box)
            conseils_story.append(Spacer(1, 8))

        return conseils_story

    # Alias pour compatibilité
    def create_conseils_with_colored_boxes(self, client: ClientData, results: NutritionResults, params: Dict[str, Any]) -> List[Any]:
        return self.create_conseils_with_colored_borders(client, results, params)

    def create_footer_clean(self) -> Paragraph:
        """Footer propre selon le prompt"""
        coach_info = self.config.get("coach_info", {})
        date_str = datetime.now().strftime("%d/%m/%Y")

        footer_style = ParagraphStyle(
            name='FooterClean',
            fontSize=9,
            textColor=HexColor('#6C757D'),
            alignment=1,
            leading=11,
            spaceAfter=10
        )

        contact_lines = []
        if coach_info.get("instagram"):
            contact_lines.append(f"@{coach_info['instagram']}")
        if coach_info.get("phone"):
            contact_lines.append(coach_info['phone'])
        if coach_info.get("email"):
            contact_lines.append(coach_info['email'])

        if contact_lines:
            contact_text = " | ".join(contact_lines)
        else:
            contact_text = "@virtus.training_ | 07 69 39 43 83 | virtustraining.fit@gmail.com"

        footer_text = f"""
        <b>Fiche établie le {date_str} par Virtus Training</b> | {contact_text}<br/>
        <i>Fiche personnalisée selon votre profil. Pour ajustement, contactez-moi.</i>
        """

        return Paragraph(footer_text, footer_style)\n\n    def create_premium_footer(self) -> List[Any]:\n        \"\"\"Footer avec s\u00e9parateur d\u00e9coratif selon le prompt sublime\"\"\"\n        coach_info = self.config.get(\"coach_info\", {})\n        date_str = datetime.now().strftime(\"%d/%m/%Y\")\n\n        footer_elements = []\n\n        # S\u00e9parateur avant footer\n        separator = HRFlowable(\n            width=\"100%\",\n            thickness=3,\n            color=HexColor('#2E86AB'),\n            spaceBefore=15,\n            spaceAfter=10\n        )\n        footer_elements.append(separator)\n\n        # Texte footer premium\n        footer_style = ParagraphStyle(\n            name='FooterPremium',\n            fontSize=9,\n            textColor=HexColor('#2C3E50'),\n            alignment=1,\n            leading=11\n        )\n\n        # Coordonn\u00e9es du coach\n        contact_parts = []\n        if coach_info.get(\"instagram\"):\n            contact_parts.append(f\"@{coach_info['instagram']}\")\n        if coach_info.get(\"phone\"):\n            contact_parts.append(coach_info['phone'])\n        if coach_info.get(\"email\"):\n            contact_parts.append(coach_info['email'])\n\n        if not contact_parts:\n            contact_parts = [\"@virtus.training_\", \"07 69 39 43 83\", \"virtustraining.fit@gmail.com\"]\n\n        contact_text = \" | \".join(contact_parts)\n\n        footer_text = f\"\"\"\n        <b>Fiche \u00e9tablie le {date_str} par Virtus Training - Coaching nutritionnel professionnel</b><br/>\n        {contact_text}<br/>\n        <i>Fiche personnalis\u00e9e selon votre profil personnel. Pour tout ajustement, contactez-moi.</i>\n        \"\"\"\n\n        footer_elements.append(Paragraph(footer_text, footer_style))\n\n        return footer_elements\n\n    # Alias pour compatibilit\u00e9\n    def create_footer_clean(self) -> List[Any]:\n        return self.create_premium_footer()"

    def add_decorative_elements(self) -> Dict[str, Any]:
        """Ajouter des éléments graphiques comme dans l'ancienne version selon le prompt"""

        def create_header_separator():
            """Séparateur coloré sous le header"""
            d = Drawing(500, 8)
            # Dégradé de couleurs
            rect1 = Rect(0, 0, 125, 8, fillColor=HexColor('#2E86AB'))
            rect2 = Rect(125, 0, 125, 8, fillColor=HexColor('#3498DB'))
            rect3 = Rect(250, 0, 125, 8, fillColor=HexColor('#E67E22'))
            rect4 = Rect(375, 0, 125, 8, fillColor=HexColor('#E74C3C'))

            d.add(rect1)
            d.add(rect2)
            d.add(rect3)
            d.add(rect4)

            return d

        def create_section_separator():
            """Séparateur pour les sections"""
            return HRFlowable(
                width="100%",
                thickness=2,
                color=HexColor('#2E86AB'),
                spaceBefore=8,
                spaceAfter=8
            )

        def create_bullet_point(color):
            """Points décoratifs pour les listes"""
            return f'<font color="{color}">●</font>'

        return {
            'header_separator': create_header_separator(),
            'section_separator': create_section_separator(),
            'bullet_point': create_bullet_point
        }

    def create_centered_section_title(self, text: str) -> Paragraph:\n        \"\"\"Cr\u00e9er un titre parfaitement centr\u00e9 avec d\u00e9coration selon le prompt\"\"\"\n        # Style pour titres centr\u00e9s\n        centered_section_style = ParagraphStyle(\n            name='CenteredSection',\n            fontSize=12,\n            fontName='Helvetica-Bold',\n            textColor=HexColor('#2E86AB'),\n            alignment=1,  # CENTR\u00c9\n            spaceBefore=10,\n            spaceAfter=8,\n            borderWidth=0,\n            borderColor=HexColor('#2E86AB'),\n            borderPadding=5\n        )\n\n        return Paragraph(f\"<b>{text}</b>\", centered_section_style)\n\n    def _add_clean_styles(self) -> None:
        """Ajouter les styles appropriés pour éviter les problèmes d'encodage selon le prompt"""

        # Styles pour éviter les problèmes d'encodage
        self.styles["section_style"] = ParagraphStyle(
            name='SectionStyle',
            fontSize=12,
            fontName='Helvetica-Bold',
            textColor=HexColor('#2E86AB'),
            spaceBefore=10,
            spaceAfter=8
        )

        self.styles["description_style"] = ParagraphStyle(
            name='DescriptionStyle',
            fontSize=10,
            fontName='Helvetica',
            textColor=HexColor('#6C757D'),
            spaceBefore=0,
            spaceAfter=0
        )

        self.styles["conseil_title_style"] = ParagraphStyle(
            name='ConseilTitle',
            fontSize=11,
            fontName='Helvetica-Bold',
            textColor=HexColor('#2C3E50'),
            spaceBefore=0,
            spaceAfter=5
        )

        self.styles["conseil_content_style"] = ParagraphStyle(
            name='ConseilContent',
            fontSize=10,
            fontName='Helvetica',
            textColor=HexColor('#2C3E50'),
            spaceBefore=0,
            spaceAfter=0,
            leading=12
        )

        # Style pour les cards
        self.styles["card_title_style"] = ParagraphStyle(
            name='CardTitle',
            fontSize=10,
            fontName='Helvetica-Bold',
            textColor=HexColor('#2C3E50'),
            alignment=1
        )

        self.styles["card_unit_style"] = ParagraphStyle(
            name='CardUnit',
            fontSize=9,
            fontName='Helvetica',
            textColor=HexColor('#6C757D'),
            alignment=1
        )

        self.styles["card_hint_style"] = ParagraphStyle(
            name='CardHint',
            fontSize=8,
            fontName='Helvetica',
            textColor=HexColor('#6C757D'),
            alignment=1
        )

    def _add_sublime_styles(self) -> None:
        """Ajouter les styles sublimes pour le prompt amélioration"""

        # Style description premium
        self.styles["description_style"] = ParagraphStyle(
            name='DescriptionPremium',
            fontSize=10,
            fontName='Helvetica',
            textColor=HexColor('#6C757D'),
            alignment=1,  # Centré
            spaceBefore=5,
            spaceAfter=10,
            leading=12
        )

    # Alias pour compatibilité
    def _create_macro_section_clean(self, results: NutritionResults) -> Table:
        return self.create_macro_section_side_by_side(results)

    def _build_macronutrient_section(self, results: NutritionResults) -> List[Any]:
        elements: List[Any] = []
        title = Paragraph(
            f"{self.icons['macros_chart']} MACRONUTRIMENTS",
            self.styles["section_title"],
        )
        elements.append(title)
        # TEXTE EXPLICATIF PREMIUM DÉTAILLÉ
        description_text = (
            "Voici vos besoins quotidiens en macronutriments (protéines, lipides, glucides) "
            "calculés selon votre profil et objectif. Le graphique présente la répartition "
            "calorique optimale pour atteindre vos résultats."
        )
        elements.append(Paragraph(description_text, self.styles["section_caption"]))
        elements.append(Spacer(1, 6))

        # Utiliser la nouvelle section SANS BUGS
        macro_section = self._create_macro_section_clean(results)
        elements.append(macro_section)

        return elements


    def _create_safe_table(self, data, col_widths=None):
        """Créer un tableau SANS BUGS - Plus de print ou objets incorrects"""
        # Nettoyer les données SANS PRINT
        clean_data = []
        for row in data:
            clean_row = []
            for cell in row:
                if cell is None or cell == "":
                    clean_row.append(Paragraph("", self.styles["body"]))
                elif hasattr(cell, '__class__') and ('Paragraph' in str(cell.__class__) or 'Image' in str(cell.__class__) or 'Table' in str(cell.__class__)):
                    clean_row.append(cell)  # Objets ReportLab valides
                elif isinstance(cell, (int, float)):
                    clean_row.append(Paragraph(str(cell), self.styles["body"]))
                else:
                    clean_row.append(Paragraph(str(cell), self.styles["body"]))
            clean_data.append(clean_row)

        # Largeurs par défaut si non spécifiées
        if col_widths is None:
            num_cols = len(clean_data[0]) if clean_data else 2
            available_width = 17 * cm  # Largeur page - marges
            col_widths = [available_width / num_cols] * num_cols

        # Créer le tableau PROPREMENT
        table = Table(clean_data, colWidths=col_widths)
        return table

    # ------------------------------------------------------------------
    # Projection de poids
    # ------------------------------------------------------------------
    def _build_weight_section(
        self,
        client: ClientData,
        results: NutritionResults,
        params: Dict[str, Any],
    ) -> List[Any]:
        elements: List[Any] = []
        title = Paragraph(
            f"{self.icons['weight']} EVOLUTION DU POIDS (12 SEMAINES)",
            self.styles["section_title"],
        )
        elements.append(title)
        elements.append(Paragraph("Projection estimee avec zone de confiance.", self.styles["section_caption"]))
        elements.append(Spacer(1, 6))

        # Graphique PREMIUM avec zone de tolérance
        weight_chart = self._create_premium_weight_chart(client, params)
        elements.append(weight_chart)  # ✅ Ajouter l'Image directement
        elements.append(Spacer(1, 10))

        # Texte informatif
        deficit = params.get("deficit_surplus_kcal", 0)
        weekly_delta = (deficit * 7) / 7700.0
        target_weight = client.poids_kg + weekly_delta * 12
        delta_text = target_weight - client.poids_kg
        info_text = (
            f"Poids actuel : {self._format_decimal(client.poids_kg, 1)} kg  "
            f"→  Poids projeté : {self._format_decimal(target_weight, 1)} kg"
            f" ({self._format_decimal(delta_text, 1)} kg)"
        )
        elements.append(Paragraph(info_text, self.styles["body"]))
        return elements

    def _create_weight_chart_with_grid(self, client: ClientData, params: Dict[str, Any]) -> Image:
        """Courbe de poids avec grille professionnelle selon le prompt"""
        deficit = params.get("deficit_surplus_kcal", 0)
        weekly_delta = (deficit * 7) / 7700.0
        weeks = np.arange(0, 13)
        current_weight = client.poids_kg

        # Évolution principale
        weights = [current_weight + (i * weekly_delta) for i in weeks]

        # ZONE DE TOLÉRANCE ±0.5kg
        poids_min = [poids - 0.5 for poids in weights]
        poids_max = [poids + 0.5 for poids in weights]

        # Couleur selon objectif
        if deficit < -100:
            color = '#E74C3C'  # Rouge pour déficit
            label_objectif = "Perte de poids"
        elif deficit > 100:
            color = '#27AE60'  # Vert pour surplus
            label_objectif = "Prise de masse"
        else:
            color = '#F39C12'  # Orange pour maintenance
            label_objectif = "Maintenance"

        # GRAPHIQUE COMPACT 300 DPI avec grille professionnelle
        fig, ax = plt.subplots(figsize=(8, 5), dpi=300)

        # GRILLE ARRIÈRE-PLAN PROFESSIONNELLE selon le prompt
        ax.grid(True, which='major', alpha=0.4, linestyle='-', linewidth=0.8, color='#E0E0E0')
        ax.grid(True, which='minor', alpha=0.2, linestyle=':', linewidth=0.5, color='#F0F0F0')

        # Activer les graduations mineures
        ax.minorticks_on()

        # Style de la grille
        ax.set_axisbelow(True)  # Grille derrière les données

        # Zone de tolérance
        ax.fill_between(weeks, poids_min, poids_max,
                       alpha=0.15, color=color,
                       label='Zone de tolérance (±0.5kg)')

        # Courbe principale
        ax.plot(weeks, weights, 'o-',
               color=color, linewidth=3, markersize=6,
               markerfacecolor='white', markeredgecolor=color,
               markeredgewidth=2, label='Évolution cible')

        # Points remarquables
        ax.scatter([0], [weights[0]], s=120, color='#2E86AB',
                  zorder=5, label='Poids actuel', edgecolor='white', linewidth=2)
        ax.scatter([12], [weights[12]], s=120, color='#27AE60',
                  zorder=5, label='Objectif 12 semaines', edgecolor='white', linewidth=2)

        # Annotations avec style
        ax.annotate(f'{weights[0]:.1f} kg',
                   xy=(0, weights[0]), xytext=(1, weights[0]+0.4),
                   arrowprops=dict(arrowstyle='->', color='#2E86AB', lw=1.5),
                   fontsize=10, fontweight='bold', color='#2E86AB')

        ax.annotate(f'Objectif {weights[12]:.1f} kg',
                   xy=(12, weights[12]), xytext=(10, weights[12]-0.4),
                   arrowprops=dict(arrowstyle='->', color='#27AE60', lw=1.5),
                   fontsize=10, fontweight='bold', color='#27AE60')

        # Styling des axes
        ax.set_xlabel('Semaines', fontsize=11, fontweight='bold')
        ax.set_ylabel('Poids (kg)', fontsize=11, fontweight='bold')
        ax.set_title('Évolution projetée du poids sur 12 semaines',
                    fontsize=12, fontweight='bold', pad=15)

        # Légende moderne
        ax.legend(loc='upper right', frameon=True, shadow=True,
                 fancybox=True, framealpha=0.9)

        # Limites des axes ajustées
        ax.set_xlim(-0.5, 12.5)
        ax.set_ylim(min(poids_min) - 0.5, max(poids_max) + 0.5)

        plt.tight_layout()

        # Sauvegarder en HAUTE RÉSOLUTION
        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight',
                   facecolor='white', edgecolor='none')
        img_buffer.seek(0)
        plt.close(fig)

        # Créer l'image ReportLab COMPACTE
        img = Image(img_buffer, width=14.0 * cm, height=8.0 * cm)
        img.hAlign = "CENTER"

        return img

    def _create_premium_weight_chart(self, client: ClientData, params: Dict[str, Any]) -> Image:
        """Wrapper pour compatibilité - utilise la nouvelle version avec grille"""
        return self._create_weight_chart_with_grid(client, params)

    # ------------------------------------------------------------------
    # Conseils personnalises
    # ------------------------------------------------------------------
    def _build_advice_section(
        self,
        client: ClientData,
        results: NutritionResults,
        params: Dict[str, Any],
    ) -> List[Any]:
        elements: List[Any] = []
        title = Paragraph(
            f"{self.icons['advice']} CONSEILS PERSONNALISES",
            self.styles["section_title"],
        )
        elements.append(title)
        elements.append(Spacer(1, 4))

        deficit = params.get("deficit_surplus_kcal", 0)
        objectif_type = self.calculator.get_objectif_description(deficit)
        weekly_delta = (deficit * 7) / 7700.0
        hydration_l = results.hydratation_ml / 1000.0
        protein_per_kg = results.proteines_g / client.poids_kg if client.poids_kg else 0

        hydration_lines = [
            f"\u2192 {self._format_decimal(hydration_l, 1)} L d'eau par jour ({int(results.hydratation_ml)} ml)",
            "\u2192 Ajoutez 250 ml avant et apres chaque seance d'entrainement",
        ]

        if objectif_type == "perte":
            timing_lines = [
                "\u2192 Gardez 60% de vos glucides autour de vos seances",
                "\u2192 Petit-dejeuner riche en proteines pour limiter les fringales",
            ]
            focus_lines = [
                f"\u2192 Deficit controle : {self._format_signed(deficit)} kcal/j (\u2248 {self._format_decimal(weekly_delta, 2)} kg/sem)",
                f"\u2192 Objectif proteines : {self._format_decimal(results.proteines_g, 1)} g/j ({self._format_decimal(protein_per_kg, 1)} g/kg)",
                "\u2192 Composez 2/3 de l'assiette avec legumes et fibres",
            ]
        elif objectif_type == "prise":
            timing_lines = [
                "\u2192 Ajoutez une collation proteinee 60 min apres la seance",
                "\u2192 Repartissez vos glucides sur 4-5 repas pour optimiser la charge",
            ]
            focus_lines = [
                f"\u2192 Surplus controle : {self._format_signed(deficit)} kcal/j (\u2248 {self._format_decimal(weekly_delta, 2)} kg/sem)",
                f"\u2192 Proteines constantes : {self._format_decimal(results.proteines_g, 1)} g/j ({self._format_decimal(protein_per_kg, 1)} g/kg)",
                "\u2192 Priorisez glucides complexes et lipides de qualite en collation",
            ]
        else:
            timing_lines = [
                "\u2192 Fixez des horaires stables (+/-30 min) pour vos repas principaux",
                "\u2192 Snack proteine et fibre en milieu d'apres-midi pour l'energie",
            ]
            focus_lines = [
                "\u2192 OBJECTIF : Ajustez +/- 150 kcal selon votre ressenti hebdomadaire",
                f"\u2192 Protéines : {self._format_decimal(results.proteines_g, 1)} g/j ({self._format_decimal(protein_per_kg, 1)} g/kg)",
                "\u2192 Conservez au moins 30 g de fibres par jour via légumes et fruits",
            ]

        attention_lines = [
            "\u2192 Priorisez des aliments frais, evitez les ultra-transformes",
            "\u2192 Surveillez la qualite du sommeil (7h minimum) pour optimiser les resultats",
        ]
        if client.age >= 45:
            attention_lines.append("\u2192 Planifiez un bilan sanguin annuel (glycemie, lipides, vitamine D)")
        attention_lines.append("\u2192 Consultez votre medecin avant toute modification majeure si antecedents")

        # Créer conseils compacts en 2 colonnes selon le prompt
        conseils_compact = self._create_compact_conseils_2pages(
            hydration_lines, timing_lines, focus_lines, attention_lines
        )
        elements.append(conseils_compact)
        return elements

    def _create_compact_conseils_2pages(
        self,
        hydration_lines: List[str],
        timing_lines: List[str],
        focus_lines: List[str],
        attention_lines: List[str]
    ) -> Table:
        """Conseils optimisés pour tenir sur 2 pages exactement selon le prompt"""

        # Styles compacts pour les boîtes
        compact_style = ParagraphStyle(
            name='CompactConseil',
            fontSize=9,  # Réduit de 10 à 9
            leading=11,  # Réduit l'interligne
            spaceAfter=4,
            spaceBefore=2
        )

        # Titres compacts
        title_compact_style = ParagraphStyle(
            name='TitleCompact',
            fontSize=10,  # Réduit de 12 à 10
            leading=12,
            fontName='Helvetica-Bold',
            spaceAfter=3,
            spaceBefore=3
        )

        # 4 sections en 2 colonnes pour économiser l'espace
        conseils_sections = [
            ('■ HYDRATATION', '→ 2,8 L d\'eau par jour (2775 ml)<br/>→ Ajoutez 250 ml avant/après entrainement', '#2E86AB'),
            ('■ TIMING DES REPAS', '→ 60% des glucides autour des séances<br/>→ Petit-déjeuner riche en protéines', '#F39C12'),
            ('■ SPÉCIFIQUE À VOTRE OBJECTIF', '<br/>'.join(focus_lines), '#27AE60'),
            ('■ POINTS D\'ATTENTION', '→ Aliments frais, évitez ultra-transformés<br/>→ Sommeil 7h minimum<br/>→ Consultez médecin si antécédents', '#E74C3C')
        ]

        # Créer 2 colonnes de conseils
        col1_conseils = []
        col2_conseils = []

        for i, (titre, contenu, couleur) in enumerate(conseils_sections):
            conseil_box = self._create_compact_conseil_box(titre, contenu, couleur, compact_style, title_compact_style)
            if i % 2 == 0:
                col1_conseils.append(conseil_box)
            else:
                col2_conseils.append(conseil_box)

        # Table en 2 colonnes
        conseils_table = Table(
            [[col1_conseils[0], col2_conseils[0]],
             [col1_conseils[1], col2_conseils[1]]],
            colWidths=[260, 260]
        )

        conseils_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('TOPPADDING', (0, 0), (-1, -1), 5),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
        ]))

        return conseils_table

    def _create_compact_conseil_box(self, titre: str, contenu: str, couleur: str, compact_style: ParagraphStyle, title_compact_style: ParagraphStyle) -> Table:
        """Boîte de conseil compacte selon le prompt"""

        conseil_data = [
            [Paragraph(titre, title_compact_style)],
            [Paragraph(contenu, compact_style)]
        ]

        conseil_table = Table(conseil_data, colWidths=[250], rowHeights=[20, 45])
        conseil_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, -1), HexColor('#FAFAFA')),
            ('BORDER', (0, 0), (-1, -1), 1.5, HexColor(couleur)),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('LEFTPADDING', (0, 0), (-1, -1), 8),
            ('RIGHTPADDING', (0, 0), (-1, -1), 8),
        ]))

        return conseil_table

    def _create_premium_conseil_box(self, icone: str, titre: str, contenu: List[str], couleur_accent: Color) -> Table:
        """Version héritée pour compatibilité"""
        # Wrapper pour l'ancienne fonction
        contenu_str = '<br/>'.join(contenu)
        compact_style = self.styles["advice_bullet"]
        title_style = self.styles["advice_heading"]
        return self._create_compact_conseil_box(f"{icone} {titre}", contenu_str, self._hex(couleur_accent), compact_style, title_style)

    # ------------------------------------------------------------------
    # Footer
    # ------------------------------------------------------------------
    def _create_footer_minimal(self) -> List[Any]:
        """Footer compact pour économiser l'espace selon le prompt"""
        elements: List[Any] = []

        coach_info = self.config.get("coach_info", {})
        date_str = datetime.now().strftime("%d/%m/%Y")

        # Style footer minimaliste
        footer_style = ParagraphStyle(
            name='FooterMinimal',
            fontSize=8,  # Plus petit
            textColor=HexColor('#6C757D'),
            alignment=1,
            leading=10,
            spaceAfter=5
        )

        # Contacts sans icônes
        contact_lines = []
        if coach_info.get("instagram"):
            contact_lines.append(f"@{coach_info['instagram']}")
        if coach_info.get("phone"):
            contact_lines.append(coach_info['phone'])
        if coach_info.get("email"):
            contact_lines.append(coach_info['email'])

        if contact_lines:
            contact_text = " | ".join(contact_lines)
        else:
            contact_text = "@virtus.training_ | 07 69 39 43 83 | virtustraining.fit@gmail.com"

        footer_text = f"""
        <b>Fiche établie le {date_str} par Virtus Training</b> |
        {contact_text}<br/>
        <i>Fiche personnalisée selon votre profil. Pour ajustement, contactez-moi.</i>
        """

        elements.append(Paragraph(footer_text, footer_style))
        return elements

    def _create_premium_footer(self) -> List[Any]:
        """Wrapper pour compatibilité"""
        return self._create_footer_minimal()

    def _build_footer(self) -> List[Any]:
        """Wrapper pour compatibilité"""
        return self._create_premium_footer()

    # ------------------------------------------------------------------
    # Generation
    # ------------------------------------------------------------------
    def generate_clean_layout_pdf(
        self,
        client: ClientData,
        results: NutritionResults,
        params_dict: Dict[str, Any],
        output_path: str,
        conseils: Optional[List[str]] = None,
    ) -> str:
        """Structure PDF sans superposition d'éléments selon le prompt"""
        try:
            doc = SimpleDocTemplate(
                output_path,
                pagesize=A4,
                topMargin=25,
                bottomMargin=25,
                leftMargin=25,
                rightMargin=25,
                title="Fiche Nutritionnelle Clean Layout - 3 Pages",
            )

            story: List[Any] = []

            # === PAGE 1 ===
            # Header propre
            story.append(self.create_clean_header())
            story.append(Spacer(1, 20))

            # Profil personnel (section complète)
            story.append(Paragraph("■ PROFIL PERSONNEL", self.styles["section_title"]))
            story.append(self.create_clean_profile_table(client, results, params_dict))
            story.append(Spacer(1, 20))

            # Cards énergétiques (SANS collision)
            story.append(Paragraph("■ BESOINS ÉNERGÉTIQUES", self.styles["section_title"]))
            story.append(Paragraph("Vue rapide sur vos calories clefs.", self.styles["section_caption"]))
            story.append(Spacer(1, 10))
            story.append(self.create_energy_cards_no_collision(results, params_dict))
            story.append(Spacer(1, 25))

            # === PAGE 2 ===
            story.append(PageBreak())

            # Macronutriments (section dédiée)
            story.append(Paragraph("■ MACRONUTRIMENTS", self.styles["section_title"]))
            story.append(Paragraph("Voici vos besoins quotidiens optimaux selon votre profil et objectif.", self.styles["section_caption"]))
            story.append(Spacer(1, 15))

            # Tableau + Pie chart CÔTE À CÔTE (pas de collision)
            macro_section = self.create_macro_section_side_by_side(results)
            story.append(macro_section)
            story.append(Spacer(1, 25))

            # Courbe de poids
            story.append(Paragraph("■ ÉVOLUTION DU POIDS (12 SEMAINES)", self.styles["section_title"]))
            story.append(self.create_weight_chart_clean(client, params_dict))
            story.append(Spacer(1, 20))

            # === PAGE 3 ===
            story.append(PageBreak())

            # Conseils avec encadrés colorés
            story.append(Paragraph("■ CONSEILS PERSONNALISÉS", self.styles["section_title"]))
            story.extend(self.create_conseils_with_colored_boxes(client, results, params_dict))
            story.append(Spacer(1, 15))

            story.append(self.create_footer_clean())

            doc.build(story)
            return output_path

        except Exception as exc:
            raise RuntimeError(f"Erreur lors de la génération du PDF clean layout: {exc}") from exc

    # Alias pour compatibilité
    def generate_perfect_2page_pdf(self, *args, **kwargs) -> str:
        return self.generate_sublime_pdf(*args, **kwargs)

    def generate_sublime_pdf(\n        self,\n        client: ClientData,\n        results: NutritionResults,\n        params_dict: Dict[str, Any],\n        output_path: str,\n        conseils: Optional[List[str]] = None,\n    ) -> str:\n        \"\"\"G\u00e9n\u00e9rer le PDF sublime avec tous les \u00e9l\u00e9ments graphiques selon le prompt\"\"\"\n        try:\n            doc = SimpleDocTemplate(\n                output_path,\n                pagesize=A4,\n                topMargin=25,\n                bottomMargin=25,\n                leftMargin=25,\n                rightMargin=25,\n                title=\"Fiche Nutritionnelle Sublime - Premium\",\n            )\n\n            story: List[Any] = []\n            decorative = self.add_decorative_elements()\n\n            # === PAGE 1 ===\n            # Header avec s\u00e9parateur d\u00e9coratif\n            story.append(self.create_perfect_header())\n            story.append(decorative['header_separator'])\n            story.append(Spacer(1, 15))\n\n            # Profil personnel\n            story.append(self.create_centered_section_title(\"\u25a0 PROFIL PERSONNEL\"))\n            story.append(self.create_clean_profile_table(client, results, params_dict))\n            story.append(Spacer(1, 20))\n\n            # Besoins \u00e9nerg\u00e9tiques avec cards color\u00e9es\n            story.append(self.create_centered_section_title(\"\u25a0 BESOINS \u00c9NERG\u00c9TIQUES\"))\n            story.append(Paragraph(\"Vue rapide sur vos calories clefs.\", self.styles[\"description_style\"]))\n            story.append(Spacer(1, 12))\n            story.append(self.create_cards_with_colored_borders(results, params_dict))\n            story.append(Spacer(1, 25))\n\n            # === PAGE 2 ===\n            story.append(PageBreak())\n\n            # Macronutriments\n            story.append(self.create_centered_section_title(\"\u25a0 MACRONUTRIMENTS\"))\n            story.append(decorative['section_separator'])\n            story.append(self.create_macro_section_side_by_side(results))\n            story.append(Spacer(1, 20))\n\n            # Courbe de poids\n            story.append(self.create_centered_section_title(\"\u25a0 \u00c9VOLUTION DU POIDS (12 SEMAINES)\"))\n            story.append(decorative['section_separator'])\n            story.append(self.create_weight_chart_with_grid(client, params_dict))\n            story.append(Spacer(1, 20))\n\n            # === PAGE 3 ===\n            story.append(PageBreak())\n\n            # Conseils avec bordures color\u00e9es\n            story.append(self.create_centered_section_title(\"\u25a0 CONSEILS PERSONNALIS\u00c9S\"))\n            story.append(decorative['section_separator'])\n            story.append(Spacer(1, 10))\n\n            # Ajouter les conseils color\u00e9s\n            conseils_elements = self.create_conseils_with_colored_borders(client, results, params_dict)\n            for conseil in conseils_elements:\n                story.append(conseil)\n\n            story.append(Spacer(1, 15))\n            story.extend(self.create_premium_footer())\n\n            doc.build(story)\n            return output_path\n\n        except Exception as exc:\n            raise RuntimeError(f\"Erreur lors de la g\u00e9n\u00e9ration du PDF sublime: {exc}\") from exc\n\n    def _create_profile_energy_combined(self, client: ClientData, results: NutritionResults, params_dict: Dict[str, Any]) -> Table:
        """Combiner profil et besoins sur une ligne pour économiser l'espace"""
        profile_section = self._build_profile_section(client, results, params_dict)[1]  # Skip title
        energy_section = self._build_energy_cards_uniform(results, params_dict)

        combined_table = Table([[profile_section, energy_section]], colWidths=[240, 280])
        combined_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('LEFTPADDING', (0, 0), (-1, -1), 0),
            ('RIGHTPADDING', (0, 0), (-1, -1), 0),
            ('TOPPADDING', (0, 0), (-1, -1), 0),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 0),
        ]))

        return combined_table

    def _create_macro_description(self) -> List[Any]:
        """Description courte des macros"""
        description_text = (
            "Voici vos besoins quotidiens optimaux selon votre profil et objectif."
        )
        return [Paragraph(description_text, self.styles["section_caption"])]

    def generate_professional_pdf(self, *args, **kwargs) -> str:
        """Wrapper pour compatibilité - utilise la nouvelle version parfaite"""
        return self.generate_perfect_2page_pdf(*args, **kwargs)

    # Alias pour compatibilité
    def generate_premium_pdf(self, *args, **kwargs):
        return self.generate_professional_pdf(*args, **kwargs)

    def generate_filename(self, client: ClientData) -> str:
        date_str = datetime.now().strftime("%Y%m%d")
        prenom_clean = "".join(c for c in client.prenom if c.isalnum())
        nom_clean = "".join(c for c in client.nom if c.isalnum())
        return f"Fiche_Premium_{prenom_clean}_{nom_clean}_{date_str}.pdf"


# Alias principal pour le générateur PDF SANS BUGS
PDFGenerator = PremiumPDFGenerator